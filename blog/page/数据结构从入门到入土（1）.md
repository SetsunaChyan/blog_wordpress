# 数据结构从入门到入土（1）

标签（空格分隔）： 数据结构

---

##单调队列&单调栈
考虑这样的一个问题:

**[Luogu]P1886**
对一个数组 $\{a_n\}\text{(1-based)}$ ，对于每一个 $1\leq l\leq n-k+1$，求 $max\{a_i\} ,i\in [l,l+k-1]$。  
$1\leq n\leq 10^6 , 1\leq k \leq n$。 

直接枚举 $O(n^2)$ 就愉快的TLE了。  
我们发现如果一个数 $a_i \geq a_j,i \geq j$ 那么显然这个 $a_j$ 不会对任何包含 $a_i$ 的子区间的最大值有任何的贡献<del>（当一个OI选手比你小还比你强，你就没用了）</del>，那么我们就可以用一个具有单调性的数据结构来维护一段移动区间的最大值。  

Talk is cheap，show me the code.   
  

**Step 1：**  
```cpp  
for(int i=1;i<=n;i++)
{
    while(h!=e&&a[q[e-1]]<a[i]) e--; //小于当前元素则出列
    q[e++]=i; 
    if(q[h]<=i-k) h++; //如果队首在区间外则出列
    //那么当前队首就是最大值
    /*
        todo...
    */
}
```

证明一下复杂度，每个元素至多入队一次出队一次，显然复杂度是 $O(n)$ 的。  

如果将区间 $[l,r]$ 改成区间 $[1,r]$，这意味着我们不需要判断队首是否在区间内，那么可以用单调栈实现（其实是一个东西）。  

**Step 2：**

那么这个东西有什么用呢？

单调队列维护一个“滑动”区间的最值，单调栈可以维护大于/小于某一个数且离它最近的数，而这样的性质常常可以拿来优化算法，减少许多不必要的操作。

来看一个优化DP的例子：

**[Luogu] P1725**
有 $n$ 个格子，对应序列 $\{a_i\}\text{(0-based)}$ ，满足 $a_0=0,|a_i|\leq1000,1\leq i\leq n$  ，一开始你站在 $a_0$ 上，当你在第 $i$ 格上时，你只能移动到 $[i+l,i+r]$ 中的任意一格上并获取该格的值，求移动到大于等于 $n$ 的格子时所能获得的最大分数。
$n\leq200000,1\leq l\leq r\leq n$ 。

很容易得到状态转移方程 $dp_i=max\{dp_j\}+a_i,j\in [i+l,i+r]$ 。

也很容易看出这样的复杂度是 $O(n*(r-l))$ 的，也就很愉快的TLE了。

我们注意到，因为 $i$ 是连续增加的，也就是说区间 $[i+l,i+r]$ 是一格一格“移动”的，那我们可以用单调队列来维护这个区间的最大值。当 $i$ 固定时，获取最值是 $O(1)$ 的，也就是说完成这个状态转移的代价是 $O(1)$ 的，总共有n个格子，那么总复杂度就是 $O(n)$ 的。于是我们对上面的代码稍加修改就能A掉这题了。  

一些简单题:
- [HDU]6319 <del>复制黏贴了一颗线段树然后TLE了</del>
- [Luogu]P1419 
- [Luogu]P1823
- [Luogu]P1901

---

##并查集

一个非常简单的东西，用来维护无向图的连通性。

**Step 1：**

每个点一开始的根都是他自己，合并的时候把这个点所在的根节点的根改成要合并的点的根即可，这样查询的时候只要查询两个点的根是否一致就行了。

然后并查集有两个常见的优化：
1. 路径压缩：如果 $A$ 是 $B$ 所在的树的根节点，$B$ 是 $C$ 的某个祖先，那么查询 $C$ 的根的时候必然会经过 $B$ ，那么我们就顺手把 $B、C$ 的父亲改成 $A$ 即可。同理，从 $C$ 到 $A$ 的整个路径上的节点都可以修改他们的父节点，这样被访问过的路径就不会被重复访问了。复杂度不会证明，给个结论，均摊复杂度 $O(n\log n)$ ，<del>但是会被毒瘤出题人构造数据卡掉。</del>
2. 按秩合并：额外开一个数组 $rank_i$ 来维护以 $i$ 为根节点的树的高度，合并时把高度低的树合并到高的树里，如果两者高度相同就任意合并一下就行了。可以发现低的往高的合并时并不会影响任何一颗树的 $rank$ 值，而高度相同时只有被合并的一颗的 $rank$ 会增大 $1$ 。复杂度还是 $O(n\log n)$ 。

大多数情况下我们习惯把两个优化同时加上，由 $Tarjan$ 证明这种情况下的并查集复杂度为 $O(n\alpha (n))$ ，其中 $\alpha(x)$ 是使 $Ackermann(m)\leq x$ 的最大整数 $m$ ，可以理解成一个增长速度极其缓慢的函数，一般可以认为 $\alpha(x)\leq 4$ 。  

看一下代码的实现：
```cpp
int find(int x)
{
    if(fa[x]==x) return x;
    else return fa[x]=find(x);
}

void Union(int x,int y)
{
    x=find(x);
    y=find(y);
    if(x==y) return;
    if(rank[x]<rank[y]) swap(x,y);
    if(rank[x]==rank[y]) rank[x]++;
    fa[y]=x;
}
```

**Step 2：**

来看一道带权值的并查集：

**[NOI2002]银河英雄传说**
有 $30000$ 支战舰，一开始第 $i$ 号战舰在第 $i$ 列，接下来有 $T$ 个指令，$M_{i,j}$ 含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。$C_{i,j}$ 表示询问第 $i$ 号战舰是否和第 $j$ 号战舰在同一列，如果在同一列中，第$ i$ 号战舰与第 $j$ 号战舰中间有多少艘战舰。
$1\leq T\leq 500000$ 。

由于 $M_{i,j}$ 与 $M_{j,i}$ 是不等价的操作，所以我们没法按秩合并，但我们可以多开始一个数组 $v_i$ 来维护第 $i$ 号战舰之前的战舰数量，这样路径压缩的同时可以一并算出来。因为合并的时候要合并到队列的尾部，所以再开一个数组 $tail_i$ 来维护第 $i$ 列战舰的尾部是几号战舰，合并的时候也只要对合并那一列的排在最前面的战舰更新下 $v$ 就行了。

核心更改如下：
```cpp
int find(int x,int &u)
{
    if(bcj[x].par==x)
    {
        u=0;
        return x;
    }
    else
    {
        bcj[x].par=find(bcj[x].par,u);
        u+=bcj[x].v;
        bcj[x].v=u;
        return bcj[x].par;
    }
}

void Union(int a,int b)
{
    int t;
    int x=find(a,t);
    int y=find(b,t);
    if(x!=y)
        bcj[x].par=bcj[y].tail;
    bcj[y].tail=bcj[x].tail;
}
```

