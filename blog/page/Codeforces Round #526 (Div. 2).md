[TOC]

## CF1084

[比赛链接](https://codeforces.com/contest/1084)

[AC代码](https://github.com/SetsunaChyan/OI_source_code)(Github)



## A.  The Fair Nut and Elevator

设楼的高度为 $0$ 到 $n-1$ ，住在 $k$ 层楼的每个人的贡献 $S_k=2 * (|k-x|+k+x)$，枚举 $x$ ，用 $\sum_{i=0}^{n-1} a_i * S_i$ 更新答案。



## B. Kvass and the Fair Nut

如果 $S=\sum_{i=1}^n v_i$ 比 $s$ 小，那么肯定无解，否则答案就是 $\lfloor \frac{S-s}{n} \rfloor$ 。



## C. The Fair Nut and String

先把非'a'且非'b'的字符全部去掉，组成一个新字符串 $s$。

记 $ans$ 为当前的答案，$b$ 为当前合法且能再加个'a'的字符串的数量。

从 $s$ 的头往后扫：

1. $s_i==\text{'a'}$

   更新 $ans=(ans+b+1)\%mod$

   表示可以不选当前字符，也可以之前的合法串加上当前字符，也可以只选当前字符

2. $s_i==\text{'b'}$

   更新 $ b=ans$



## D. The Fair Nut and the Best Path

其实就是求树上某条链的点权减去边权的最大和。

记 $dp_i$ 表示到节点 $i$ 时的最大和，初始值是 $v_i$。

 $dfs$ 时更新 $dp_i$ ，再用 $dp_i$ 往子树搜，回溯时更新 $dp_i$ 来保证在已搜完的子树里经过该点的值是最大的。

答案就是 $max(dp_i)$。



## E. The Fair Nut and Strings

观察样例 $s=aba$ ，$t=bba$ 。

我们先不考虑 $k$ 对我们写字符串的限制。

先固定后面两位，改变前面两位，得到字符串 $aba$ 与 $bba$ 。

此时它对前缀个数的贡献是这两个字符串的所有前缀，$ans=6$。

再固定后面一位，对前面所有得到的字符串改变前面两位，得到新字符串 $baa$。

因为前缀 $b$ 已经出现过了，所以有贡献的只有长度大于等于 $2$ 的前缀，$ans=6+2=8$。

再不固定任何一位，我们可以从现有的 $aba$ 中派生出 $abb$ ，$baa$ 得到 $bab$ 。

注意我们不能从 $bba$ 得到 $bbb$ ，因为后者大于了 $t$ 。

因为任何长度小于等于 $2$ 的前缀已经出现过了，所以只有长度为 $3$ 的前缀有贡献，$ans=8+2=10$。



我们一位一位的考虑，就可以不重不漏的考虑所有字符串的情况，然后统一计算他们的贡献。

当我们有了只能选 $k$ 个字符串的限制的时候，在考虑固定了后 $i$ 位时，每从这一位多派生一个字符串，就能多获得 $i+1$ 个前缀。这意味着我们得到了这样一个策略：总是优先派生能派生的字符串。



设当前在比较的字符是第 $i$ 位（从 $1$ 开始，即固定了后 $n-i$  位），只改变前 $i-1$ 位能得到的不同字符串数是 $pre$ 。设 $temp$ 表示算上当前位能够新增的字符串数。

1. $t_i>s_i$

   所有 $s$ 前缀的 $* b$ 和所有 $t$ 前缀的 $* a$ 都能成为新的不同字符串，即 $temp=pre$。($ * $ 表示所有之前得到的 $pre$ 个不同字符串，下同）

2. $s_i==t_i==a(==b)$

   除了与 $s$ 或 $t$ 相同前缀的 $* a(b)$ 都能构成新的字符串，同时还有与 $s$ 相同前缀的 $* b$ （与 $t$ 相同前缀的 $* a$)，即 $temp=pre-2+1=pre-1$ 。

3. $s_i>t_i$ 

   除了与 $s$ 或 $t$ 相同前缀的 $* a(b)$ 都能构成新的字符串，即 $temp=pre-2$。

对 $ans$ 的贡献是 $min(k,temp) * (n-i+1)$，对 $pre$ 的贡献就是 $temp$ ，再 $k=k-temp$。

$i==1$ 的时候要特判一下，对 $ans$ 的贡献是 $min(k,(更新前的pre+temp)) * (n-i+1)$，因为 $s$ 和 $t$ 本身也能有贡献。



## F.  Max Mex

Not soloved.

